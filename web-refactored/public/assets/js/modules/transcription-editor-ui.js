/**
 * TranscriptionEditorUI
 * Displays and manages the editing interface for transcription data.
 */
export class TranscriptionEditorUI {
    /**
     * @param {ApiClient} apiClient - An instance of the ApiClient.
     * @param {string} containerSelector - Selector for the main container where the transcription editor will be rendered.
     * @param {string} segmentTemplateSelector - Selector for the HTML <template> element for a single segment.
     * @param {string} wordTemplateSelector - Selector for the HTML <template> element for a single word.
     */
    constructor(apiClient, containerSelector, segmentTemplateSelector, wordTemplateSelector) {
        this.apiClient = apiClient;
        this.containerElement = document.querySelector(containerSelector);
        this.segmentTemplate = document.querySelector(segmentTemplateSelector);
        this.wordTemplate = document.querySelector(wordTemplateSelector);

        if (!this.containerElement) {
            console.warn(`TranscriptionEditorUI: Container element with selector \"${containerSelector}\" not found.`);
        }
         if (!this.segmentTemplate) {
            console.warn(`TranscriptionEditorUI: Segment template with selector \"${segmentTemplateSelector}\" not found.`);
        }
         if (!this.wordTemplate) {
            console.warn(`TranscriptionEditorUI: Word template with selector \"${wordTemplateSelector}\" not found.`);
        }

        this.transcriptionData = null; // To store the transcription data being edited
        console.log("TranscriptionEditorUI initialized.");
    }

    /**
     * Initializes the TranscriptionEditorUI module by setting up event listeners.
     */
    initialize() {
        // Listen for the event dispatched after transcription is completed
        document.addEventListener('transcriptionCompleted', this._handleTranscriptionCompleted.bind(this));
        console.log("TranscriptionEditorUI event listener set up.");

        // TODO: Potentially add logic here to load existing transcription if it's already in session on page load
        // This would involve calling apiClient.get('/api/transcription/current')
    }

    /**
     * Handles the custom transcriptionCompleted event.
     * @param {CustomEvent} event - The transcriptionCompleted event containing transcription data.
     */
    _handleTranscriptionCompleted(event) {
        console.log('TranscriptionEditorUI: Transcription completed event received.', event.detail);
        if (event.detail && event.detail.transcription) {
            this.transcriptionData = event.detail.transcription;
            this._renderTranscription(this.transcriptionData.captions); // Assuming 'captions' array holds the segments/words
        } else {
             console.error(\'TranscriptionEditorUI: Received transcriptionCompleted event but no transcription data found in detail.\', event.detail);\n         }\n     }\n\n     /**\n      * Renders the transcription data into the editor container.\n      * @param {Array<object>} captions - The array of caption objects (segments/words).\n      */\n    _renderTranscription(captions) {\n        if (!this.containerElement || !captions) {\n            console.warn(\'TranscriptionEditorUI: Cannot render transcription. Container or captions data is missing.\');\n            return;\n        }\n\n        this.containerElement.innerHTML = \'\'; // Clear previous content\n\n        // Simple grouping logic: assume each entry in 'captions' array from the service is a word or a short phrase.\n        // A more advanced editor would group words into lines/segments based on timing and potentially UI width.\n        // For now, let\'s treat each 'caption' entry as a renderable unit, perhaps grouping them visually into segments.\n        // Let\'s assume the structure from the transcription service provides words or small groups already.\n        // Based on the transcription service README, the 'captions' array contains objects with text, startMs, endMs.\n        // We will treat each entry as a 'word' for now and group them into simple segments.\n\n        let segmentIndex = 0;\n        let currentSegmentElement = null;\n\n        captions.forEach((caption, index) => {\n            // Basic heuristic: Start a new segment if the previous caption ended more than X ms ago,\n            // or if it's the very first caption.\n            const previousCaption = index > 0 ? captions[index - 1] : null;\n            const segmentBreakThreshold = 500; // ms, heuristic for detecting pauses between spoken phrases\n\n            if (!currentSegmentElement || (previousCaption && (caption.startMs - previousCaption.endMs > segmentBreakThreshold))) {\n                // Start a new segment\n                segmentIndex++;\n                if (currentSegmentElement) {\n                     // Optional: Add a visual separator between segments\n                     // const separator = document.createElement(\'hr\');\n                     // this.containerElement.appendChild(separator);\n                }\n\n                if (this.segmentTemplate) {\n                     const templateContent = this.segmentTemplate.content;\n                     currentSegmentElement = document.importNode(templateContent, true).firstElementChild;\n                     if (currentSegmentElement) {\n                         currentSegmentElement.dataset.segmentIndex = segmentIndex.toString();\n                         // Find and populate segment timing inputs\n                         const startTimeInput = currentSegmentElement.querySelector(\'.segment-start-time\');\n                         const endTimeInput = currentSegmentElement.querySelector(\'.segment-end-time\');\n\n                         if (startTimeInput) startTimeInput.value = this._formatTime(caption.startMs); // Start time of the first word\n                         if (endTimeInput && captions[index+1]) endTimeInput.value = this._formatTime(captions[captions.length-1].endMs); // Placeholder: end time of the last word in this segment (needs refinement)\n\n                         const textEditor = currentSegmentElement.querySelector(\'.segment-text-editor\');\n                         if (textEditor) {\n                             textEditor.contentEditable = \"true\"; // Make the text area editable\n                              // Event listener for input changes on the editable div (more complex than inputs)\n                             textEditor.addEventListener(\'input\', this._handleSegmentInputChange.bind(this, segmentIndex));\n                         }\n\n                          // Add event listeners to segment action buttons if they exist in the template\n                         const splitButton = currentSegmentElement.querySelector(\'.button-split-segment\');\n                         if (splitButton) splitButton.addEventListener(\'click\', () => this._handleSplitSegment(segmentIndex));\n                         const mergeButton = currentSegmentElement.querySelector(\'.button-merge-segment-prev\');\n                         if (mergeButton) mergeButton.addEventListener(\'click\', () => this._handleMergeSegmentWithPrevious(segmentIndex));\n                         const deleteButton = currentSegmentElement.querySelector(\'.button-delete-segment\');\n                         if (deleteButton) deleteButton.addEventListener(\'click\', () => this._handleDeleteSegment(segmentIndex));\n\n                         this.containerElement.appendChild(currentSegmentElement);\n                     } else {\n                          console.error(\'TranscriptionEditorUI: Failed to create segment element from template.\');\n                          currentSegmentElement = null; // Fallback might be needed or stop rendering\n                     }\n                } else { // Fallback if no segment template\n                     const basicSegment = document.createElement(\'div\');\n                     basicSegment.className = \'segment basic-segment\';\n                     basicSegment.dataset.segmentIndex = segmentIndex.toString();\n                      const textEditor = document.createElement(\'div\');\n                     textEditor.className = \'segment-text-editor basic\';\n                     textEditor.contentEditable = \"true\";\n                      textEditor.addEventListener(\'input\', this._handleSegmentInputChange.bind(this, segmentIndex));\n                     basicSegment.appendChild(textEditor);\n                     this.containerElement.appendChild(basicSegment);\n                     currentSegmentElement = basicSegment; // Set current segment to the basic one\n                      console.warn(\'TranscriptionEditorUI: Using basic segment rendering. Provide a template for full features.\');\n                }\n            }\n\n            // Add the word/caption to the current segment\n            if (currentSegmentElement) {\n                const textEditor = currentSegmentElement.querySelector(\'.segment-text-editor\');\n                if (textEditor) {\n                    const wordElement = this._createWordElement(caption);\n                    if (wordElement) {\n                         // Add a space before the word, unless it's the first word in the segment\n                         if (textEditor.children.length > 0) {\n                             textEditor.appendChild(document.createTextNode(\' \'));\n                         }\n                        textEditor.appendChild(wordElement);\n                    }\n                }\n                // Update the end time of the segment based on the current word's end time\n                const endTimeInput = currentSegmentElement.querySelector(\'.segment-end-time\');\n                if (endTimeInput) { // Update with the latest word's end time\n                    endTimeInput.value = this._formatTime(caption.endMs);\n                }\n            }\n        });\n\n        console.log(`TranscriptionEditorUI: Rendered ${captions.length} captions into ${segmentIndex} segments.`);\n    }\n\n    /**\n     * Creates an HTML element for a single word/caption.\n     * @param {object} caption - The caption object { text, startMs, endMs }.\n     * @returns {HTMLElement|null} The created word element.\n     */\n    _createWordElement(caption) {\n        if (!this.wordTemplate) {\n             const span = document.createElement(\'span\');\n             span.className = \'word basic\';\n             span.textContent = caption.text;\n             span.dataset.startMs = caption.startMs.toString();\n             span.dataset.endMs = caption.endMs.toString();\n             // span.contentEditable = \"true\"; // Make words individually editable? More complex.\n             return span;\n             // console.warn(\'TranscriptionEditorUI: Using basic word rendering. Provide a template for full features.\');\n        }\n\n        try {\n            const templateContent = this.wordTemplate.content;\n            const wordElement = document.importNode(templateContent, true).firstElementChild;\n\n            if (wordElement) {\n                 wordElement.textContent = caption.text;\n                 wordElement.dataset.startMs = caption.startMs.toString();\n                 wordElement.dataset.endMs = caption.endMs.toString();\n                 // wordElement.contentEditable = \"false\"; // Set based on template attribute or here\n                 return wordElement;\n            } else {\n                console.error(\'TranscriptionEditorUI: Failed to create word element from template.\');\n                return null;\n            }\n        } catch (e) {\n            console.error(\'TranscriptionEditorUI: Error using word template:\', e);\n            // Fallback to basic rendering on error\n             const span = document.createElement(\'span\');\n             span.className = \'word basic fallback\';\n             span.textContent = caption.text;\n             span.dataset.startMs = caption.startMs.toString();\n             span.dataset.endMs = caption.endMs.toString();\n             return span;\n        }\n    }\n\n    /**\n     * Placeholder: Handle input changes in a contenteditable segment.\n     * @param {number} segmentIndex - The index of the segment being edited.\n     * @param {Event} event - The input event.\n     */\n    _handleSegmentInputChange(segmentIndex, event) {\n        // This is complex. Changes in a contenteditable div don't easily map back to the original word/timing structure.\n        // A robust editor would need to re-parse the content, potentially re-aligning text to timings.\n        console.log(`Segment ${segmentIndex} input changed. Current text:`, event.target.textContent);\n        // TODO: Implement logic to capture changes and update the internal transcriptionData model.\n    }\n\n     /**\n      * Placeholder: Handle split segment button click.\n      * @param {number} segmentIndex - The index of the segment to split.\n      */\n     _handleSplitSegment(segmentIndex) {\n         console.log(`Split segment ${segmentIndex} requested.`);\n         // TODO: Implement splitting logic (needs complex text/timing manipulation)\n     }\n\n      /**\n      * Placeholder: Handle merge segment button click.\n      * @param {number} segmentIndex - The index of the segment to merge (with the previous one).\n      */\n     _handleMergeSegmentWithPrevious(segmentIndex) {\n         console.log(`Merge segment ${segmentIndex} with previous requested.`);\n          // TODO: Implement merging logic\n     }\n\n      /**\n      * Placeholder: Handle delete segment button click.\n      * @param {number} segmentIndex - The index of the segment to delete.\n      */\n     _handleDeleteSegment(segmentIndex) {\n         console.log(`Delete segment ${segmentIndex} requested.`);\n          // TODO: Implement deletion logic\n     }\n\n    /**\n     * Formats milliseconds into HH:MM:SS.ms or MM:SS.ms.\n     * @param {number} ms - Time in milliseconds.\n     * @returns {string} Formatted time string.\n     */\n    _formatTime(ms) {\n        const totalSeconds = Math.floor(ms / 1000);\n        const milliseconds = ms % 1000;\n        const seconds = totalSeconds % 60;\n        const minutes = Math.floor(totalSeconds / 60) % 60;\n        const hours = Math.floor(totalSeconds / 3600);\n\n        const pad = (num, length = 2) => num.toString().padStart(length, '0');\n\n        if (hours > 0) {\n            return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}.${pad(milliseconds, 3)}`;\n        } else {\n            return `${pad(minutes)}:${pad(seconds)}.${pad(milliseconds, 3)}`;\n        }\n    }\n\n    // Future methods:\n    // - saveChanges(): Sends edited transcription data back to the backend.\n    // - updateTiming(): Allows editing segment/word timings.\n    // - syncWithVideo(): Highlight words/segments as video plays.\n    // - loadTranscription(data): Method to load transcription data directly if fetched separately.\n}\n```
